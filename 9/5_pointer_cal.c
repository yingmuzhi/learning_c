
/**
 * 指针的运算
 * 给指针类型的值加1，实际上指针值(地址)加上的sizeof(指针类型);
 *      int *q = 0;
 *      printf("q+1 is %p\n", q+1); // 其实是0x4，因为-m32上一个int是4字节。即sizeof(int) = 4;
 *
 * 之所以“指针加'1'，加上的是sizeof(类型)”的主要原因，是为了和数组产生关系，让指针指向下一个变量
 *      int a[10];
 *      int *p = a;
 *      *(p+n) <==> a[n] // 这两个是等价的
 *
 * 两个指针之间做减法的意思是需要除以sizeof(指针类型的)
 *      int a[13];
 *      int *p1 = a;
 *      int *p2 = a[3];
 *      printf("p2 - p1 is %d\n", p2-p1); // 则输出为3
 *
 * 常见的操作有*p++:意思是取出p所指的那个数据来，完事儿后将p移动到下一个位置去
 *  *的优先级虽然高，但是没有++高
 *  常用于数组类连续空间操作
 *  在一些CPU上可以直接被翻译成一条汇编指令
 *      while ( *p != -1 ){
 *          printf("%d\n", *p++);
 *      }
 *
 * 指针可以进行比较，指针比较的本质是地址的比较，而且数组的地址依次递增，故a<a[10]必然正确。指针比较本质上是地址大小的比较。
 *
 * 0地址(建议用NULL来表示0地址及未初始化的指针)
 *  我们内存中有0地址，OS中多进程的操作系统有虚拟内存(-m32就是4GB)，每一块虚拟内存从0开始编址，但是0地址通常是一个不能随便碰的地址，所以我们的指针不应该具有0值。
 *  我们一般用0地址表示特殊的事情，如：
 *      返回的指针是无效的
 *      指针没有被真正初始化（先初始化为0）
 *  NULL是一个预先定义的符号，表示0地址
 *      有的编译器不愿意我们用0来表示0地址，所以我们该用NULL来表示0地址
 *
 * 指针的类型，指针有很多种类型，但是无论指向什么类型，所有的指针大小都是一样的，因为都是地址，大小只和机器字长有关。
 * 指向不同类型的指针是不能相互赋值的，这是为了避免用错指针。
 *
 * void *指针表示不知道指向什么东西的指针，计算的时候与char *相同，但是并不相通
 *
 * 指针的类型转换
 * int *p = &i; void *q = (void *)p;
 * 但是这并没有改变p所指的变量的类型，只不过让后人用不同的眼光通过p看它指向的变量，即解释的方法改变了：
 *      “我不再当你是int啦，我认为你就是个void！我当你什么都不是了！”
 */

#include <stdio.h>

int main(int argc, const char *argv[]){
    int *q = 0;
    printf("q+1 is %p\n", q+1);

    return 0;
}
