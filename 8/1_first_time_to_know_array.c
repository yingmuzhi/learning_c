
/**
 * 数组用于记录读进来的每一个数
 *      int number[100];
 *      while (x != -1){
 *          number[cnt] = x;
 *          ...
 *      }
 *
 * 定义数组<类型> 变量名称[元素数量];
 *      int grades[100];
 *      double weight[20];
 * 注意：元素数量必须是整数，在C99之前元素数量必须是编译时候确定的字面量（后来可以用常量或者确定值的变量）。
 * 数组是一种容器(放东西的东西),它具有的特点有：
 *      所有的元素具有相同的数据类型；
 *      一旦创建不能改变大小；
 *      数组中的元素在内存中是连续依次排列的；（顺序排列）
 *      从a[0]开始到a[n-1]；数组的下标或者叫索引是从0开始计数的。
 * 编译器或者运行环境是不会检查数组下标是否越界的，一旦程序因为数组越界而崩溃会出现诸如“Abort trap”，“segmentation fault”之类的字眼。
 *
 * int a[0]; // 长度为0的数组是可以存在的，编译是可以通过的，但是没有任何用处。
 *
 * 定义数组后要使用循环进行初始化
 *      int count[10];
 *      int i;
 *      for( i = 0; i<10; i++ ){
 *          count[i] = 0;
 *      }
 * 尽量少使用magic number 10，建议改成const int NUMBER = 10;
 * 故一般定义一个数组包括以下五个步骤
 *      const int NUMBER = 10;  // 规定数组大小
 *      int count[NUMBER];      // 定义数组
 *      
 *      for ( int i = 0; i < NUMBER ; i++ ){
 *          count[i] = 0;
 *      }                       // 初始化数组
 *
 *      ...                     // 数组参与计算
 *
 *      ...                     // 遍历数组输出
 *
 * 数组的集成初始化
 *      int a[] = { 2, 4, 6, 8, };
 *      int a[13] = {0}; // 则下标为0的地方数值为0，1-12全部12个元素都默认初始化为0
 *      int a[10] = { [0] = 0, [2] = 3, 6, }; // 则可以在指定的位置赋值, 其余未赋值的都是0。适用于C99稀疏矩阵。
 *      int a[] = { [1] = 2, [5] = 6, }; // 则数组大小为6。
 * 
 * 判断数组大小，使用sizeof()
 *      sizeof(a) / sizeof(a[0]);
 *
 * 数组的赋值，不能将一个数组的值直接赋值给另一个数组。实际上数组是一种const的东西。
 * 要把一个数组的所有元素交给另一个数组，必须采用遍历。
 *
 * 遍历数组一般采用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i正好是数组最大的有效下标。
 *
 * 数组作为函数参数时，往往必须再用另一个参数传入数组的大小
 *
 * 在查询一个函数是什么意思或者如何使用的时候可以直接在终端中输入：
 *      man sqrt
 *
 * 写程序就是学习前人的套路
 * 调试代码时候将调试代码使用大括号括起来，这样就确保了不会影响总体的本地变量/局部变量。
 *
 * 二维数组，通常将二维数组a理解为一个矩阵。
 *      int a[3][5]; // 3行5列的矩阵
 *      从a[0][0]到a[2][4]
 * 二维数组的遍历需要两重遍历，分别遍历行号和列号
 *      for (i...) {
 *          for (j...) {
 *
 *          }
 *      }
 * a[i, j]的意思是a[j]
 *
*
*/

/**
 * 二维数组的定义方式
 *      int a[][5] = {
 *          {0, 1, 2, 3, 4},
 *          {2, 3, 4, 5, 6},
 *      };
 * 列数必须给出的，行数可以由编译器来数
 * 每行一个{},使用逗号分隔
 * 最后的逗号由于古老传统可以存在
 * 如果省略表示补零
 * C99之后可以用定位
 */
