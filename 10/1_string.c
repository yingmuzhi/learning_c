
/**
 * 字符串
 *      char word[] = {"H', '\0'}; // 因为有了0所以它从字符数组成为了一个字符串
 * 字符数组
 *      char word[] = {'H', 'e', 'l', 'l', 'o', '!'};
 * 字符串的定义
 *  以0（整数0）结尾的一串字符
 *      0和'\0'是一样的，但是和'0'不同
 *  0标志字符串的结束，但它不是字符串的一部分
 *      计算字符串长度的时候不包含这个0
 *  字符串以数组的形式存在，以数组或指针的形式访问
 *      更多的是以指针的形式进行访问
 *  <string.h>中有很多处理字符串的函数
 *
 * 字符串变量，字符串的本质是以'\0'结尾的字符数组
 *      char *str = "hello";
 *      char word[] = "hello"; 
 *      char line[10] = "hello"; // "hello"有5个字符，字符串长度为6，因为占据了6个字节的位置
 *
 * 如果两个字符串间不加任何符号，两个字符串会自动连接
 *
 * C语言的字符串是以字符数组的形态存在的
 *  不能用运算符对字符串做运算
 *  通过数组的方式可以遍历字符串
 * 唯一特殊的地方是字符串字面量可以用来初始化字符数组
 */

/**
 * 字符串常量
 *      char *s = "hello, world!"; // 位于程序的代码段，是只读的
 *      char *s2= "hello, world!"; // s和s2指向同一个地址
 *  s是一个指针，初始化为指向一个字符串常量
 *  由于这个常量所在的地方，实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法
 *  试图对s所指的字符串做写入会导致严重的后果
 *  如果需要修改字符串，应该用数组：
 *      char s[] = "hello, world!";
 *  char *不一定是字符串，只有其指向的字符数组结尾为0或者\0才是字符串
 */

/**
 * 字符串输入输出，运行时构造字符串都用char string[99]数组的形式。
 *      char string[8]; // 字符串长度为8，但是只能放7个字符，因为还有一个结尾的0需要占据一个字节
 *      scanf("%s", string); // scanf读入一个单词，到空格，tab或回车为止
 *      printf("%s", string);
 *
 *      scanf("%7s", string); // 这个是安全的方法，告诉用户最多只能读7个字符
 *
 * 常见错误
 *      char *string;
 *      scanf("%s", string); // string没有初始化为0，char *是字符指针，不是字符串类型。定义的变量string没办法直接使用
 *
 * 空字符串
 *      char buffer[100] = ""; // 这个数组的长度为100，但是这是一个空的字符串，buffer[0] == '\0'
 *      char buffer[] = ""; // 这个数组的长度只有1，buffer[0] == '\0'
 */

/**
 * 字符串数组，推荐使用char *a[99];
 *      char **a; // a是一个指针，指向另一个指针，那个指针指向一个字符(串)
 *      char a[][10]; // a[0] <==> char [10]; 每个字符数组大小固定为10
 *      char *a[]; // a[0] <==> char *; 每一个a[0]相当于一个字符指针，那个指针指向一段字符串，字符串的大小并不固定
 *      // 其实是很好理解的，可以视作把[]给去除，则一个a[0]相当于char *a;
 * 
 * 程序参数
 *      int main(int argc, char const *argv[]); // argv[0]是命令本身，当使用Unix的符号链接时，反映符号链接的名字
 * Unix可以做程序链接，如
 *      ln -s a.out my // 在terminal中输入，将a.out和my做链接
 */

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

