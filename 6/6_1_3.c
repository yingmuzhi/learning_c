/**
 * 补码
 */

#include <stdio.h>

int main(){
    char c = 255;
    int i = 255;
    printf("c = %d, i = %d\n", c, i);
    // c在内存中是11111111
    // i在内存中是00000000 00000000 00000000 11111111
    return 0;
}


// 1和-1，如果1是00000001,那么-1就是11111111，因为-1和1相加要得到0
//
// -1到-128 和1到127，能表示256个数，负数每次都多一个, 而0则占据正数中的0000000的位置(故正数少一个)
// 比如int 表达的范围就是：-2的31次方到+2的31次方-1
// 越界问题可以看做一个头尾相接的圆圈⭕️进行理解。故越界了后可能会显示负数，因为在内存中，第一个1代表的是符号位，如果为1则代表负数，如果为0则代表正数
// 使用"unsigned char c = 255"的意思是不用补码的形式表示数字，即11111111表示的是正数255。故unsigned表达的正数部分扩大，而负数部分则没有。unsigned的初衷是为了做纯二进制运算，主要为了位移运算。
// 整数的输入输出只有两种形式:int 或者 long long ；%d-int ; %u-unsigned (int); %ld-long long ; %lu-unsigned long long
//      另外%d等都是以十进制的方式来查看，"char c = 012"是八进制的, "int i = 0x12"是十六进制的
//      %o按八进制们进行输出，%x按十六进制进行输出
// 现在cpu字长普遍是64位或者32位, 而这么多数据类型一般对底层硬件操作的时候才需要区分。故推荐一般使用int作为基本类型
//
